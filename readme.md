## shMAX72xxMini - небольшая быстрая библиотека для работы с драйверами MAX7219 и MAX7221

Создана на основе библиотеки LedControl - http://wayoda.github.io/LedControl/

Основные возможности библиотеки:
- управление состоянием светодиодов подключенных устройств поштучно, по строкам и по столбцам;
- управление положением изображения - поворот и отражение по горизонтали (по строкам) в случае необходимости (привет китайским светодиодным модулям)

Библиотека может использоваться для работы как со светодиодными матрицами 8х8 светодиодов, так и с семисегментными цифровыми индикаторами, управляемыми драйверами **MAX7219** и **MAX7221**

Версия 1.0 - 26.07.2022
- заменены типы используемых данных для уменьшения потребления памяти;
- увеличено максимальное количество устройств в каскаде до 31 шт.;
- работа с драйвером переведена на аппаратный SPI, что хорошо сказалось на производительности библиотеки;
- убраны одни и добавлены другие методы; в том числе:
- добавлена возможность поворота изображения и зеркального отражения его по горизонтали (т.е. по строке) при необходимости;
- добавлена возможность обновления изображения на всех устройствах одновременно;

### Класс shMax72xxMini

При создании объекта **shMax72xxMini** нужно сразу указать количество используемых устройств в модуле и номер пина Ардуино для подключения вывода **CS** (или **LOAD**) модуля:

`MAX72xxMini<8> disp(10);`

Здесь:
- 10 - номер   пина Ардуино для подключения вывода **CS** (или **LOAD**) модуля;
- 8 - количество используемых в модуле устройств, может быть установлено в интервале 1-31;

Выводы **DataIn** (**DIN**) и **CLK** модуля подключаются соответственно к пинам **MOSI** и **CLK** Ардуино (для Ардуино Uno/NANO/Pro Mini это пины **D11** и **D13** соответственно)

Для начала работы с модулем нужно вывести устройства, используемые в нем, из режима сна, т.е. включить их:

`disp.shutdownAllDevices(false);`

если же указать параметр true, то модуль наоборот будет переведен в режим сна, при этом информация в его регистрах сброшена не будет.

Тоже самое можно проделать с каждым устройством модуля в отдельности:

`disp.shutdownDevice(0, false);`, где **0** - порядковый индекс устройства в модуле.

Если используются светодиодные матрицы 8х8 светодиодов, то может понадобиться поворот изображения и (или) зеркальное отражение его по горизонтали (т.е. по строкам). Для этого используются методы:

`disp.setDirection(2);`, где **2** - угол поворота изображения, может быть задан в интервале 0-3;

`disp.setFlip(true);`, где **true** включает отражение, **false** - отключает отражение изображения;

Оба метода вносят настройки для всех устройств модуля одновременно.

Остальные методы класса **shMax72xxMini**

`uint8_t getDeviceCount()` - получение количества устройств в модуле; (нужно понимать, что пересчитать реальное количество устройств невозможно, поэтому будет возвращено значение, использованное при создании экземпляра класса);

`void setScanLimit(uint8_t addr, uint8_t limit)` - установка лимита обработки строк устройством с индексом **addr**; значение **limit** может быть задано в интервале 1-8.

Если задать лимит меньше 8, то устройство будет отображать информацию только на заданном количестве строк. Это может быть полезно, если к устройству подключено, например, всего 4 семисегментных индикатора вместо возможных 8; (нужно понимать, что эта настройка вносится в регистры драйвера и не учитывает заданный угол поворота изображения, т.е. будут работать только светодиоды, подключенные к соответствующим выводам микросхемы драйвера).

`void setBrightness(uint8_t addr, uint8_t intensity)` - установка яркости свечения светодиодов устройства с индексом **addr**; значение **intensity** может быть задано в интервале 0-15, при этом значение 0 не отключает светодиоды полностью - они будут светиться с минимальной яркостью.

`void clearDevice(uint8_t addr, bool upd = false)` - очистить изображение на устройстве с индексом **addr**; если параметр **upd == false**, то будет очищен только программный буфер устройства, само изображение будет сброшено только после вызова метода `update()`.

`void clearAllDevices(bool upd = false)` - очистить изображение на всех устройствах; если параметр **upd == false**, то будет очищен только программный буфер устройств, само изображение будет сброшено только после вызова метода `update()`.

`void setLed(uint8_t addr, uint8_t row, uint8_t column, boolean state, bool upd = false)` - установить состояние одиночного светодиода на устройстве с индексом **addr** с координатами **row** (строка, координата **Y**) и **column** (столбец, координата **X**); **state** - устанавливаемое состояние светодиода - включен/выключен; метод учитывает заданные поворот и отражение изображения; если параметр **upd == false**, то изменение будет внесено только в программный буфер устройства, само изображение будет обновлено только после вызова метода `update()`.

`void setRow(uint8_t addr, uint8_t row, uint8_t value, bool upd = false)` - установка на устройстве с индексом **addr** строки с индексом **row**; строка определяется значением **value** - состояние каждого светодиода строки определяется значением соответствующего бита в параметре **value**: 1 - включен, 0 - выключен; метод учитывает заданные поворот и отражение изображения; если параметр **upd == false**, то изменение будет внесено только в программный буфер устройства, само изображение будет обновлено только после вызова метода `update()`.

`void setColumn(uint8_t addr, uint8_t column, uint8_t value, bool upd = false)` - установка на устройстве с индексом **addr** столбца с индексом **column**; столбец определяется значением **value** - состояние каждого светодиода столбца определяется значением соответствующего бита в параметре **value**: 1 - включен, 0 - выключен; метод учитывает заданные поворот и отражение изображения; если параметр **upd == false**, то изменение будет внесено только в программный буфер устройства, само изображение будет обновлено только после вызова метода `update()`.

`void update()` - обновление изображения (вывод содержимого программного буфера) на всех устройствах модуля;

Если возникнут вопросы, пишите на valesh-soft@yandex.ru 